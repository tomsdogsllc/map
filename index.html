<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
  crossorigin=""
/>

<link href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800,900&display=swap" rel="stylesheet">

<style>
  :root{
    --td-cream:#FFF6E5;
    --td-cream-2:#F7F4ED;
    --td-deep:#0f1b12;
    --td-green:#315532;
    --td-sage:#5E7C60;
    --td-accent:#D9772A;

    --td-border: rgba(49,85,50,0.22);
    --td-shadow: 0 18px 40px rgba(15,27,18,0.16);

    --td-radius: 18px;
  }

  html, body{
    height:100%;
    margin:0;
    background: transparent;
    font-family: "Nunito", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }

  .td-geo-app{
    height: 520px;
    padding: 14px;
    border-radius: var(--td-radius);
    overflow:hidden;
    background:
      radial-gradient(1100px 740px at 16% -10%, rgba(94,124,96,0.18), transparent 60%),
      radial-gradient(900px 650px at 92% 0%, rgba(217,119,42,0.12), transparent 65%),
      rgba(247,244,237,0.55);
    border: 1px solid var(--td-border);
  }

  @media (max-width: 860px){
    .td-geo-app{
      height: 380px;
      padding: 10px;
    }
  }

  #td-geo-map{
    height:100%;
    width:100%;
    border-radius: var(--td-radius);
    border: 1px solid var(--td-border);
    box-shadow: var(--td-shadow);
    overflow:hidden;
    background:#fff;
  }

  .leaflet-control-zoom,
  .leaflet-control-attribution{
    border-radius: 14px !important;
    overflow:hidden;
  }

  .leaflet-control-zoom a{
    background: rgba(247,244,237,0.92) !important;
    color: rgba(15,27,18,0.88) !important;
    border:0 !important;
  }

  .leaflet-control-attribution{
    background: rgba(247,244,237,0.82) !important;
    color: rgba(15,27,18,0.70) !important;
    border: 1px solid rgba(49,85,50,0.14) !important;
    box-shadow: 0 10px 20px rgba(15,27,18,0.10);
  }

  .leaflet-popup-content-wrapper{
    border-radius: 16px !important;
    border: 1px solid rgba(49,85,50,0.18);
    background: rgba(255,246,229,0.96) !important;
    color: rgba(15,27,18,0.92);
    box-shadow: 0 18px 34px rgba(15,27,18,0.18);
  }

  .leaflet-popup-tip{
    background: rgba(255,246,229,0.96) !important;
    border: 1px solid rgba(49,85,50,0.14);
  }

  .td-popup-title{
    font-weight: 800;
    font-size: 14px;
    margin: 0 0 6px 0;
    color: rgba(15,27,18,0.92);
  }
  .td-popup-sub{
    font-weight: 700;
    font-size: 12px;
    margin: 0;
    color: rgba(15,27,18,0.72);
  }
  .td-popup-note{
    font-weight: 700;
    font-size: 12px;
    margin: 8px 0 0 0;
    color: rgba(49,85,50,0.86);
  }
</style>

<div class="td-geo-app">
  <div id="td-geo-map"></div>
</div>

<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>

<script>
(() => {
  const apiKey = "f82ea38cb77543d59c597faaa263e714";

  const originName = "Toby May Park";
  const origin = { lat: 41.3274358, lon: -72.1034902 };

  const milesToMeters = mi => Math.round(mi * 1609.344);

  const zoneMiles = 17;
  const zoneMeters = milesToMeters(zoneMiles);

  // Popular trail pins (geocoded by name+town; then filtered to the isoline polygon)
  const trails = [
    { name: "Rocky Neck State Park", address: "Rocky Neck State Park, East Lyme, CT" },
    { name: "Oswegatchie Hills Nature Preserve", address: "Oswegatchie Hills Nature Preserve, East Lyme, CT" },
    { name: "Avery Farm Nature Preserve", address: "Avery Farm Nature Preserve, Ledyard, CT" },
    { name: "Harkness Memorial State Park", address: "Harkness Memorial State Park, Waterford, CT" },
    { name: "Nehantic State Forest", address: "Nehantic State Forest, East Lyme, CT" },
    { name: "Gillette Castle State Park", address: "Gillette Castle State Park, East Haddam, CT" },
    { name: "Lay Allen Preserve", address: "Lay Allen Preserve, Old Lyme, CT" },
    { name: "The Griswold Preserve", address: "The Griswold Preserve, Old Lyme, CT" },
    { name: "Darrow Pond Property", address: "Darrow Pond, Lyme, CT" },
    { name: "Connecticut College Arboretum", address: "Connecticut College Arboretum, New London, CT" },
    { name: "Stenger Farm", address: "Stenger Farm Park, Waterford, CT" },
    { name: "Bluff Point State Park", address: "Bluff Point State Park, Groton, CT" },
    { name: "Haley Farm State Park", address: "Haley Farm State Park, Groton, CT" },
    { name: "Upper Three Mile River Preserve", address: "Upper Three Mile River Preserve, East Lyme, CT" },
    { name: "Mitchell Woods", address: "Mitchell Woods, New London, CT" },
    { name: "Mamacoke Hill", address: "Mamacoke Hill Preserve, Waterford, CT" }
  ];

  const map = L.map("td-geo-map", { scrollWheelZoom: false })
    .setView([origin.lat + 0.070, origin.lon], 11);

  const isRetina = L.Browser.retina;
  const baseUrl = "https://maps.geoapify.com/v1/tile/osm-carto/{z}/{x}/{y}.png?apiKey={apiKey}";
  const retinaUrl = "https://maps.geoapify.com/v1/tile/osm-carto/{z}/{x}/{y}@2x.png?apiKey={apiKey}";
  L.tileLayer(isRetina ? retinaUrl : baseUrl, { maxZoom: 20, apiKey }).addTo(map);

  // Panes
  map.createPane("outside-dim");
  map.getPane("outside-dim").style.zIndex = 410;
  map.getPane("outside-dim").style.pointerEvents = "none";

  map.createPane("zone-fill");
  map.getPane("zone-fill").style.zIndex = 420;

  map.createPane("markers-top");
  map.getPane("markers-top").style.zIndex = 650;

  map.createPane("markers-trails");
  map.getPane("markers-trails").style.zIndex = 640;

  // Icons
  const originIcon = L.icon({
    iconUrl: `https://api.geoapify.com/v2/icon/?type=circle&color=%23315532&strokeColor=%230f1b12&size=44&icon=home&iconType=awesome&contentSize=24&noWhiteCircle&scaleFactor=2&apiKey=${apiKey}`,
    iconSize: [44, 44],
    iconAnchor: [22, 22],
    popupAnchor: [0, -26]
  });

  const trailIcon = L.icon({
    iconUrl: `https://api.geoapify.com/v2/icon/?type=circle&color=%23D9772A&strokeColor=%230f1b12&size=42&icon=tree&iconType=awesome&contentSize=22&noWhiteCircle&scaleFactor=2&apiKey=${apiKey}`,
    iconSize: [42, 42],
    iconAnchor: [21, 21],
    popupAnchor: [0, -24]
  });

  L.marker([origin.lat, origin.lon], { icon: originIcon, pane: "markers-top" })
    .addTo(map)
    .bindPopup(`Home Base: ${originName}`);

  // Service area style
  const serviceFill = "rgba(94,124,96,0.30)";
  const serviceOutline = "rgba(49,85,50,0.78)";
  const outsideDimFill = "rgba(15,27,18,0.55)";

  let serviceRingLonLat = null; // [[lon,lat],...]

  function firstRingFromFeature(feature){
    const g = feature && feature.geometry;
    if (!g) return null;

    if (g.type === "Polygon" && Array.isArray(g.coordinates) && g.coordinates[0]) {
      return g.coordinates[0];
    }
    if (g.type === "MultiPolygon" && Array.isArray(g.coordinates) && g.coordinates[0] && g.coordinates[0][0]) {
      return g.coordinates[0][0];
    }
    return null;
  }

  function ensureClosed(ring){
    if (!ring || ring.length < 3) return ring;
    const first = ring[0];
    const last = ring[ring.length - 1];
    if (first && last && first[0] === last[0] && first[1] === last[1]) return ring;
    return ring.concat([first]);
  }

  // Ray-casting point-in-polygon
  function pointInPolygonLonLat(point, polygon){
    if (!polygon || polygon.length < 4) return true; // if no polygon, don't filter
    const x = point[0], y = point[1];
    let inside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      const xi = polygon[i][0], yi = polygon[i][1];
      const xj = polygon[j][0], yj = polygon[j][1];
      const intersect = ((yi > y) !== (yj > y)) &&
        (x < (xj - xi) * (y - yi) / ((yj - yi) || 1e-12) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  // Geocode helper (Geoapify)
  function geocodeOne(text){
    const url = "https://api.geoapify.com/v1/geocode/search" +
      `?text=${encodeURIComponent(text)}` +
      "&format=json&limit=1" +
      `&apiKey=${encodeURIComponent(apiKey)}`;

    return fetch(url)
      .then(r => r.ok ? r.json() : Promise.reject())
      .then(j => {
        const item = j && j.results && j.results[0];
        if (!item || typeof item.lat !== "number" || typeof item.lon !== "number") return null;
        return { lat: item.lat, lon: item.lon };
      })
      .catch(() => null);
  }

  const trailLayer = L.layerGroup([], { pane: "markers-trails" }).addTo(map);

  function addTrailPins(){
    trailLayer.clearLayers();

    const tasks = trails.map(t =>
      geocodeOne(`${t.address}`).then(pt => ({ ...t, pt }))
    );

    Promise.all(tasks).then(results => {
      results.forEach(t => {
        if (!t.pt) return;

        const isInside = pointInPolygonLonLat([t.pt.lon, t.pt.lat], serviceRingLonLat);
        if (!isInside) return;

        const popupHtml =
          `<div class="td-popup-title">${t.name}</div>` +
          `<div class="td-popup-sub">${t.address}</div>` +
          `<div class="td-popup-note">Popular trail spot</div>`;

        L.marker([t.pt.lat, t.pt.lon], { icon: trailIcon, pane: "markers-trails" })
          .bindPopup(popupHtml)
          .addTo(trailLayer);
      });
    });
  }

  function drawSingleZone(data){
    const zoneFeature = (data.features || []).find(
      f => typeof f?.properties?.range === "number" && f.properties.range === zoneMeters
    );
    if (!zoneFeature) {
      addTrailPins();
      return;
    }

    const ring = ensureClosed(firstRingFromFeature(zoneFeature));
    if (!ring) {
      addTrailPins();
      return;
    }

    // Save for filtering trail pins
    serviceRingLonLat = ring;

    // Dim everything outside the service area (world polygon with a hole)
    const worldOuter = [
      [-180, -90],
      [ 180, -90],
      [ 180,  90],
      [-180,  90],
      [-180, -90]
    ];
    const innerHole = ring.slice().reverse();

    const maskFeature = {
      type: "Feature",
      properties: {},
      geometry: { type: "Polygon", coordinates: [worldOuter, innerHole] }
    };

    L.geoJSON(maskFeature, {
      pane: "outside-dim",
      interactive: false,
      style: () => ({
        color: "transparent",
        weight: 0,
        opacity: 0,
        fillColor: outsideDimFill,
        fillOpacity: 1
      })
    }).addTo(map);

    // Draw the service area itself
    const baseStyle = { weight: 1.35, opacity: 0.95, fillOpacity: 0.30 };
    const hoverStyle = { weight: 1.85, opacity: 0.98, fillOpacity: 0.38 };

    const layer = L.geoJSON(zoneFeature, {
      pane: "zone-fill",
      style: () => ({
        color: serviceOutline,
        weight: baseStyle.weight,
        opacity: baseStyle.opacity,
        lineJoin: "round",
        lineCap: "round",
        dashArray: "2 6",
        fillColor: serviceFill,
        fillOpacity: baseStyle.fillOpacity
      })
    }).addTo(map);

    layer.on("mouseover", () => layer.setStyle(hoverStyle));
    layer.on("mouseout", () => layer.setStyle(baseStyle));

    // Fit around zone + origin
    try{
      const b = layer.getBounds();
      map.fitBounds(b.extend([origin.lat, origin.lon]).pad(0.13));
    } catch(e){}

    addTrailPins();
  }

  const isolineUrl =
    `https://api.geoapify.com/v1/isoline?lat=${origin.lat}&lon=${origin.lon}` +
    `&type=distance&mode=drive&range=${zoneMeters}&apiKey=${apiKey}`;

  fetch(isolineUrl)
    .then(res => res.json())
    .then(drawSingleZone)
    .catch(() => {
      serviceRingLonLat = null;
      addTrailPins();
    });
})();
</script>
